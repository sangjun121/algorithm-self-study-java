# DP(Dynamic Programing) 동적프로그래밍

## 동적프로그래밍
- 작은 문제의 결과를 이용해서, 큰 문제의 정답을 빠르게 계산하는 알고리즘을 의미
- 장점은, 규격화된 형태가 있음. 코딩량도 많지 않음

## DP 접근 시나리오
- 우선 문제를 읽자마자, DP라고 판단하기에 처음엔 어려울 수 있다. 문제가 원하는 정답을 찾기 위해, 가장 먼저 완전탐색(Brute-Force) 접근을 시도한다.
- 완탐 과정에서 탐색하는 경우가 지나치게 많아서, 시간이나 공간적으로 힘들것 같은 경우, DP를 고려하자.

## DP 문제풀이 순서(규격화)
1. 풀고 싶은 가짜 문제를 정의하기
   - 이때, 코테에 나오는 가짜 문제는 상당히 제한되어 있음. 유형을 최대한 체화하자.
   - 예를 들어 진짜 문제가 수열 A[1~N]에서 조건을 만족하는 부분 수열의 개수를 구하라! 라고 가정하자.
   - 이때, A[1~i] (i는 1부터, N까지 가능하다고 정의)에서 조건을 만족하는 부분 수열의 개수를 모두 저장한 배열 Dy[i]를 찾을 수 있다면, Dy[n]의 원소 값을 가져오면 된다.
   - 즉, 피보나치 수열처럼, i에 대한 점화식을 찾아내고 N번째 원소의 값을 계산하는 방식
2. 가짜 문제를 풀면 진짜 문제를 풀수 있는지 확인
3. 초기값은 어떻게 되는가?
   - 위의 예시로 i=1,2,3일때쯤(직접 계산하기 쉬울때까지의 값들)의 값을 찾아내기
4. 점화식 찾아내기
   - 예: Dy[i-2] + Dy[i-1] = Dy[i]

## 유형1. 진짜 문제랑 똑같은 가짜 문제인 경우 - 문제 크기N을 변수로 만들어서 표기하는 경우
- 진짜 문제를 먼저 써보기. 예를 들어, 주어진 N에 대해서 N을 1,2,3으로 표현하는 경우의 수
- 위의 워딩을 보고 가짜 문제 써보기. 예를 들어, Dy[i]: i 를 1,2,3의 합으로 표현한 경우의 수
- Dy[i]에서 i =1,2,3일때는 수기로 구하고, 그 이후부터는 Dy[i-1] + Dy[i-2] + Dy[i-3] = Dy[i]가 될 것이다.
    - 위의 솔루션을 찾기 위해 하나의 팁을 추가하자면, Dy[i] 계산에서 필요한 탐색 경우를 공통점끼리 묶어낸다. 결국 마지막에 무엇이 있었는지로 묶기. 위의 예시에서는 마지막에 합산식을 썻을 때 어떤 숫자가 마지막에 오는지로 분리하기
    - 즉, 마지막에 1이 더해지는 경우의 수는 Dy[i-1]과 동일할 것이며, 같은 논리로 위의 점화식이 나온다.
- 즉, 이때는 Dy[i]의 배열을 채우는 O(n)의 시간 복잡도면 충분하다. 
- 다수의 테케를 처리하기 전에 모든 N에 대해 정답을 구해두자.

## 유형2. 문제 크기 N과 마지막 상태를 함께 기록해주어야 하는 경우
- 구체적으로 설명하자면, 유형1로 풀려고 시도했으나 가짜문제가 진짜 문제를 해결할 수 없을 때, 즉, 새로운 조건이 하나 더 추가되야함을 깨닫고, 가짜 문제를 수정하는 케이스
- 예시 (BOJ2579 계단 오르기): i-1를 통해 i를 구할 수 있겠다고 생각했지만, i-1에서 i-2를 밟았는지의 조건이 필요한 경우 (BOJ2579 계단 오르기)
- 예시: BOJ11057 오르막수

### 심화탐구. 역추적(backTrack): 어떤 경우로 해당 결과가 도출되었는가?
**⭐️대부분의 코딩테스트의 경우 유형 1,2에서 커버가 된다.**

## 유형3. 구간 L~R에 대한 문제를 해결할 때
## 유형4. 2차원 격자 배열에서 문제를 해결할 때
## 유형5. 트리 구조에서 문제를 해결할 때


# 대표 유형
1. BOJ12865 평범한 배낭 (0-1 knapsack)
