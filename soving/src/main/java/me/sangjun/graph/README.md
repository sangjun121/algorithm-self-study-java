## BOJ1260 DFS와 BFS

### 문제풀이시 막혔던 사항
1. Map 자료구조를 사용하여 그래프의 인접리스트를 구현하는 경우, 빈 Key에 대해 리스트 초기화해주는 것에서 오류 발생
   - 웬만하면 computeIfAbsent를 숙지하고, 기억이 나지 않는 경우 조건문으로 작성하자.
2. BufferedWriter에 대한 flush 사용 시점. 이 부분에 대한 정확한 공부가 필요할듯 하다. 
   - 해당 부분은 study/io 파트에 정리
3. Collections.sort()의 시간복잡도 정확히 암기하기.

## BOJ2667 단지번호 붙이기
- 빈출 유형. 그래프로 해석하여 푸는 문제 유형.
- 정답의 최대치는 N이 최대 25이기 때문에, 대략 625개의 집이 생성될 수 있다. 또한 최대 단지의 수는 0,1이 반복되는 구조이기에 최대 약 300개의 단지(N^2/2)가 형성될 수 있다.
   - 따라서 저장하는 공간은 Integer 범위에 포함된다. (항상, 저장하는 자료형의 범위를 고려하자.)
- 이 문제처럼 2차원 배열에 표현된 그래프를 **격자형 그래프**라고 한다. 격자형 그래프를 코드로 표현하는 방법을 익히자. 정점과 간선을 어떻게 표현할지 고민하면 된다.
  - 이 문제에서는 각 격자 한칸이 정점. 인접하는 격자가 같은 값(1)인 경우, 간선으로 해석하면 된다. 
- 처음에 내가 푼 방법은 인접하는 점(동 서 남 북)에 대해, 조건문 if로 계산하였다. 이렇게 수작업으로 작성해주게 되면, 이번 문제는 조건이 4개이기에 괜찮지만 많아지는 경우 코드를 작성하기에 어려워진다.
  - **따라서 간선의 관계를 표현하는 배열을 만들면 이를 해결할 수 있다.**
  - 이 문제에서는 dir[4][2] = { (-1,0), (0,1) , (1,0) ,(0,-1) } 을 미리 저장하고, 모든 정점에 대해 해당 배열의 원소를 더해 인접한 정점을 구하면 된다.
- 시간 복잡도는 정점의 개수가 N^2개 간선의 개수는 N^2 * 4이므로 인접리스트로 구현한다면, 시간복잡도는 O(2E)이므로 O(N^2)이 된다.
- 우선 핵심은  **[따라서 간선의 관계를 표현하는 배열을 만들면 이를 해결할 수 있다.](../../../../../../../study/graph/README1.md)** 이 부분임을 잊지 말자.
