## 백준 14425 문자열 집합

#### 첫번째 시도

- 처음에는 각 입력값을 ```List<String>```에 담아 contains 시 count를 1씩 증가시키는 방법으로 구현, 단 시간소요가 너무 많이 발생
- 2892ms 발생 (2.892초)
- 이때 시간 복잡도는 O(N * M) (여기서 N과 M은 각각 비교 대상자 문자열의 개수, 비교할 문자열의 개수 )
- 1 ≤ N ≤ 10,000, 1 ≤ M ≤ 10,000) 1억번의 연산 발생(java 기준으로 1초면 3000만회의 연산정도로 하한선 기준 가능)
- **제한 시간이 1초인 문제는 연산 횟수가 3,000만이 넘는 알고리즘은 사용하면 안된다.**

#### 두번째 시도
- 사전 순으로 정렬하여 이진 탐색 진행
- 아래 궁금한점의 계산법으로 최대 2억회 정도의 연산이 필요.

### 궁금했던점

1. Collections.sort()의 시간복잡도

- 답변: Collections.sort()는 내부적으로 리스트를 먼저 배열로 복사한다. 그리고 Arrays.sort() 호출하고 리스트로 변환하기에 ```Arrays.sort()```의 시간복잡도를 따라간다.
- 객체 타입의 정렬은 TimSort를 사용하기 때문의 최악의 경우 O(N log N × L) 만큼의 시간 복잡도가 발생
- 구체적으로 살펴보자. ```List<String>``` 일때는  ```String.compareTo(String)```를 통해 정렬을 진행한다. 이때는 문자열 길이(L)만큼의 시간복잡도가 걸린다.(문제에서 문자열
  길이는 500으로 제한된다.)
- 또한 TimSort의 시간 복잡도가 O(N log N) 이기 때문에 최종적으로는 O(N log N × L)의 시간복잡도가 발생한다.
- 최종적으로 문제의 조건을 읽어보면, 문서,단어의 최대개수는 10,000개이므로 정렬에만 사용되는 소요 연산은 2 * 10000 * log2 10000 * 500 = (약 1억 3천만)이다.

2. 이진 탐색의 소요시간
- 답변: 이진 탐색의 소요시간은 O(log N)이다. 결국 10000개의 문서에 대해 해당 메소드를 실행하기 때문에, 10000 * log2 10000 * 500 = 약 6천6백만회 이다.
